#!/usr/bin/env bash

XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
PYTHON_VENV_HOME="${PYTHON_VENV_HOME:-${XDG_DATA_HOME}/python/venvs}"

display_help() {
  cat << 'EOF'

  Create and activate Python virtual environments.

  Works best assuming multiple versions of python > 3.5 and a single
  version of Python 2, perhaps installed by Nix.

  Usage: pyv [global options] cmd [...]

  Commands

  new [--python|-p] venv : Create a new virtual env named $venv in
  $XDG_DATA_HOME/python/venvs.  If the optional --python flag is
  given a path to a python binary, that version is used to create
  the virtual env. The default value is python3.

  Example:
    pyv --python=python2 myvenv
    pyv --python=~/.nix-profile/bin/python3.5 myvenv


  del venv  : delete the virtual env named venv
  list | ls : list current virtual envs

EOF
}

# Activate a particular virtual env.  This command is exposed
# in the binary so that other executables, such as the dotfiles
# script, can make use of virtual envs without havint to source
# the interactive shell wrapper version.
cmd_activate() {
  local f="${PYTHON_VENV_HOME}/${1}/bin/activate"
  if [ -e "${f}" ]; then
    echo "Activating ${PYTHON_VENV_HOME}/${1}."
    source "${f}"
  else
    echo "Virtual env ${1} does not exist."
    exit 1
  fi
}


# Delete a virtual env.
cmd_del() {
  if [ ! -z "${1}" ] && [ -e "${PYTHON_VENV_HOME}/${1}" ]; then
    rm -rf "${PYTHON_VENV_HOME}/${1}"
  fi
}


# Use the tool $1 to create a venv $2, where $2 is a full path.
new_from_tool() {
  if [ -z "${1}" ] || [ -z "${2}" ]; then
    echo "No virtual env tool or venv name passed."
    exit 1
  fi

  local tool="${1}"
  local venv="${2}" # full path

  echo "Using ${tool} to create ${venv}".

  if command -v "${tool}" >/dev/null 2>&1; then
    "${tool}" "${venv}"
  else
    echo "Could not find virtual env tool ${tool}."
    exit 1
  fi
}

# Create a new virtual env $1 in $PYTHON_VENV_HOME using the python binary specified in
# the --python option.
cmd_new() {
  local python="python3" # default python to use

  # parse opts
  while true; do
    case "${1}" in
      "--python=" | "-p=")
        python="${1#*=}"
        shift
        ;;
      *)
        break
    esac
  done

  local path
  if [ -z "${1}" ]; then
    echo "No venv name passed."
    exit 1
  else
    path="${PYTHON_VENV_HOME}/${1}"
  fi

  local ver="$(${python} --version)"

  if [ -e "${path}" ]; then
    echo "Virtual env ${path} already exists."
    return 0
  fi

  case "${ver}" in
    "Python 3.5"*)
      echo "Running ${python} -m venv ${path}"
      "${python}" -m venv "${path}"
      ;;
    "Python 3"*)
      new_from_tool "pyvenv" "${path}"
      ;;
    "Python 2"*)
      new_from_tool "virtualenv" "${path}"
      ;;
  esac
}


cmd_list() {
  ls ${PYTHON_VENV_HOME} 
}

main() {
  mkdir -p "${PYTHON_VENV_HOME}"

  local cmd="${1}"
  shift

  while true; do
    case "${cmd}" in
       new | del)
        "cmd_${cmd}" "${@}"
        break
        ;;
      ls | list)
        cmd_list "${@}"
        break
        ;;
      use | act | activate)
        cmd_activate "${@}"
        break
        ;;
      *)
        echo "Command ${1} not recognized."
        display_help
        exit 1
        ;;
      esac
  done

  exit
}

main "${@}"

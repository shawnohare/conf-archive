#!/usr/bin/env bash

source "lib/bash/xdg/xdg.sh"
source "lib/bash/pkg/pkg.sh"
source "lib/posix/echo.sh"

readonly DOTFILES="${DOTFILES:-${HOME}/dotfiles}"
readonly DOTFILES_REPO="${DOTFILES_REPO:-https://github.com/shawnohare/dotfiles.git}"
readonly LOGFILE="${LOGFILE:-${XDG_VAR_HOME}/dotfiles/log}"
readonly PYENV_ROOT="${PYENV_ROOT:-${XDG_BIN_HOME}/stow/pyenv}"

# ---------------------------------------------------------------------------
# Global variables
# true/false are functions that return 0/1, resp.
# ---------------------------------------------------------------------------
declare verbose=false
declare debug=false
declare dry=false
declare logging=false

# ---------------------------------------------------------------------------
# Packages
# ---------------------------------------------------------------------------

# Get or update a config dependency hosted by Github.
# Wrapper for get_git_repo
get_github_opt() {
  local repo="$1";
  if [[ -z "${repo+x}" ]]; then
    $debug && echo "Repository name required."
    exit 1
  fi
  get_git_repo -u "https://github.com/${repo}.git" "${XDG_OPT_HOME}/${repo}"
}

# Get external dependencies that are not otherwise managed.
get_opts() {
  local opts=(
    "zsh-users/zsh-history-substring-search"
    "zsh-users/zsh-syntax-highlighting"
    "zsh-users/zsh-completions"
    "zsh-users/zsh-autosuggestions"
  )

  for opt in "${opts[@]}"; do
    $verbose || echo "Getting opt package ${opt}"
    $dry || get_github_opt "${opt}"
  done
  # get_github_opt "powerline/fonts"
  # Install powerline fonts.
  # $dry || bash "${XDG_OPT_HOME}/powerline/fonts/install.sh"
}

get_pkgs() {
  # TODO: write a nix script to do this.
  # Also, we might need to compile neovim from source still.
  local pkgs=(ag curl git go neovim stow tmux wget zsh)
  for pkg in "${pkgs[@]}"; do
    $verbose && echo "Checking for package: ${pkg}"
    $dry || get_pkg "${pkg}"
  done
}



display_help() {
  cat << 'EOF'

Usage: dotfiles.sh [-dhlv] [cmd]

Arguments:

-a arg : do something with a_arg
-d : Execute a dry-run.  The system state is not changed.
-h : print this help message.
-l : echo to the logfile specified in the LOGFILE env variable.
-v : run in verbose mode to print debugging statements.

Commands:

init ostype [distro] [pkg install cmd]

  Put the system in a state where the rest of the configuration
  commands will work.  This will create the necessary directories
  and install external tools needed to get packages and link configs.

  Supported values for ostype are {macos, linux}.
  Supported values for distro are {null, debian, ubuntu, arch, nixos}.

  Example usages:

    init macos
    init linux debian
    init linux debian "apt-get install -y"


install ostype [distro] [pkg install cmd]

  Fully install the dotfiles. This is mainly a slight extension of the
  init command that installs a few useful tools such as the nix
  package manager, zsh, and pyenv.


link [-a] [dir1 dir2 ...]

  Link dotfile dirs.  This will copy the directory substructure of each
  dotfiles dir and then use GNU stow to symlink the contents.  The --all flag
  is not necessary, and provided for semantic purposes.  Additional arguments
  for the stow command are passed through.  For example
    link --restow : calls stow dir --restow

EOF
}

# extract any options with getopts
parse_opts() {
  OPTIND=1
  while getopts ":a:dhlpv:" opt "${@}"; do
    case "${opt}" in
      a)
        # option -a is set with argument $OPTARG
        echo "Option -a is set with argument: ${OPTARG}"
        ;;
      d)
        dry=true
        echo "Dry run. State will not change."
        ;;
      h)
        # print help message
        display_help
        exit 0
        ;;
      l)
        logging=true
        ;;
      p)
        prompt_user=true
        echo "User prompts enabled."
        ;;
      v)
        case "${OPTARG}" in
          3)
            echo "Verbosity level 3: debug."
            debug=true
            verbose=true
            ;;
          2)
            echo "Verbosity level 2: verbose."
            verbose=true
            ;;
          1)
            echo "Verbosity level 1: normal."
            ;;
          *)
            echo "Verbosity level ${OPTARG} unknown. Defaulting to levle 1."
            ;;
        esac
        ;;
      \?)
        echo "Invalid option: -${OPTARG}"
        display_help
        exit 1
        ;;
      :)
        echo "Option -${OPTARG} requires an argument"
        display_help
        exit 1
        ;;
    esac
  done
}


# FIXME: deprecated
# link a dotfiles dir to the home dir.
# First copy the directory's structure, and then use GNU stow to
# link the files.  This setup ensures that program data does not
# accidentally end up in the dotfiles directories, which can happen
# when entire directories are linked.
# TODO: it might be nice to remove the dependency on stow here.
# link_dir() {
#   local dir="${1}"
#   echo "Linking ${dir}"
#   shift
#   cd "${DOTFILES}/${dir}" || exit 1

#   # copy dir struct
#   $dry || find . -type d -exec mkdir -p -- "${HOME}"/{} \;
#   cd "${DOTFILES}" || exit 1
#   # call stow with the link_dir options

#   local opts
#   $verbose && opts="--verbose"
#   opts="${opts} ${@}"
#   $dry || stow ${opts} --target="${HOME}" "${dir}"
# }




#-------------------------------------------------------------------------
# commands
# Commands are responsible that required packages are installed.
# This leads to some minor duplication, but means that the checking
# occurs in a common location.
#-------------------------------------------------------------------------


# link each folder in the dotfiles root to the home dir.
# Usage: link [--restow] [--ignore=dir] [--all] dir1 dir2 ...
cmd_link() {
  local ignores=( emacs ignore )
  local paths=()

  cd "${DOTFILES}" || echo --error "${DOTFILES} does not exist."
  while true; do
    case "$1" in
      --ignore=* | -i=*)
        local ig="${1#*=}"
        shift
        ignores+=("${ig}") # append
        ;;
      "--all")
        for path in *; do
          $verbose && echo "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
      *)
        for path in "${@}"; do
          $verbose && echo "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
    esac
  done

  $verbose && echo "Beginning to link dirs."
  for path in "${paths[@]}"; do
    if [ ! -d  "${path}" ]; then
      $verbose && echo "Not linking non-dir ${path}"
      continue
    fi

    # Determine if the path is ignored
    local should_link=true
    for ignore in "${ignores[@]}"; do
      if [ "${path}" == "${ignore}" ]; then
        echo "Not linking ignored dir ${path}"
        should_link=false
        break
      fi
    done

    if $should_link; then
      local args=( '--force' )
      $verbose && args+=('--verbose')
      "${DOTFILES}/bin/bin/lndir" "${args[@]}" "${DOTFILES}/${path}" "${HOME}"
    fi
  done

}

# inititialize the os ($1) & distro ($2) with the optional install command ($3).
# This should put things into a state where all the other commands work.
cmd_init() {
  $dry || get_nix

  # make dirs
  $verbose && echo "Making necessary dirs."
  if ! $dry; then
    mkdir -p "${XDG_CONFIG_HOME}"
    mkdir -p "${XDG_DATA_HOME}"
    mkdir -p "${XDG_CACHE_HOME}"
    mkdir -p "${XDG_STATE_HOME}"
    mkdir -p "${XDG_BIN_HOME}"
    mkdir -p "${XDG_LIB_HOME}"
    mkdir -p "${XDG_TMP_HOME}"
    mkdir -p "${XDG_OPT_HOME}"
    mkdir -p "${XDG_VAR_HOME}"
    mkdir -p "${HOME}/bin"
    mkdir -p "${HOME}/tmp"
  fi

  return 0
}

cmd_python() {

  # Define the stable versions of python
  local vmain="3.5.2"
  local v3="${vmain}"
  local v2="2.7.12"
  local pyenv
  pyenv="${PYENV_ROOT}/bin/pyenv"

  $dry || get_pyenv

  # create virtual envs for neovim
  # NOTE: the versions here should be updated occasionally
  local vers=( "${v2}" "${v3}" "${vmain}" )
  for ver in "${vers[@]}"; do
    if ! $dry && [ ! -e "${PYENV_ROOT}/versions/${ver}" ]; then
      $verbose && echo "Pyenv is installing ${ver}".
      ${pyenv} install "${ver}"
    fi
  done


  $verbose && echo "Creating neovim virtual envs."
  if ! $dry; then
    ${pyenv} virtualenv "${v2}" "neovim2"
    ${pyenv} virtualenv "${v3}" "neovim3"
    eval "$(${pyenv} init -)"
  fi


  $verbose && echo "Installing modules in neovim virtual envs."
  local venvs=( "neovim2" "neovim3" )
  for venv in "${venvs[@]}"; do
    local pip="${PYENV_ROOT}versions/${venv}/bin/pip"
    if ! $dry; then
      "${pip}" install --upgrade pip
      "${pip}" install --upgrade "neovim"
      "${pip}" install --upgrade "jedi"
    fi
  done

  # link some python binaries so they are available to external
  # programs, regardless of the current python environment.
  # This is mostly to expose linters and autoformatters.
  $verbose && echo "Installing and linking python binaries."
  if ! $dry; then
    ${pyenv} global "${vmain}" "${v3}" "${v2}"
    local mods=( 'autoflake' 'flake8'  'pylint' 'ipython' )
    pip="${PYENV_ROOT}/versions/${vmain}/bin/pip"
    for mod in "${mods[@]}"; do
      "${pip}" install --upgrade "${mod}"
      ${pyenv} rehash
      local dest="${XDG_BIN_HOME}/${mod}"
      [ -L "${dest}" ] && rm "${dest}"
      ln -s "${PYENV_ROOT}/versions/${vmain}/bin/${mod}" "${dest}"
    done
  fi

  return 0
}

cmd_zsh() {
  echo "Setting up zsh."
  get_pkg "zsh"


  local zsh_path
  zsh_path="$(which zsh)"
  $debug && echo "zsh path: ${zsh_path}"

  # Append Homebrewed zsh path to /etc/shells to authorize it as a login shell
  if grep -q "${zsh_path}" /etc/shells; then
    echo "Adding ${zsh_path} to /etc/shells."
    $dry || printf "%s" "${zsh_path}" | sudo tee -a /etc/shells
  fi

  # Change this user's default shell to Homebrewed zsh
  if [[ ${SHELL} != "${zsh_path}" ]]; then
    echo "Changing this user's default shell to zsh."
    $dry || chsh -s "${zsh_path}" "${USER}"
  fi
  return 0
  exit 0
}

cmd_install() {
  echo "Installing dotfiles."

  cmd_init
  get_pkgs
  get_opts
  cmd_zsh
  cmd_python
  cmd_link
  echo "Finished installing."
  exit 0
}

parse_cmd() {
  local cmd="${1}"
  shift
  # Execute the named command and pass it the args that follow.
  # For example, "cmd_${@}" could expand to cmd_foo arg1 arg2 arg3.
  case "${cmd}" in
    init | install | neovim | python | zsh)
      "cmd_${cmd}" "${@}"
      exit 0
      ;;
    link | ln)
      cmd_link "${@}"
      exit 0
      ;;
    help)
      display_help
      exit 0
      ;;
    *)
      echo "Command ${cmd} not recognized".
      display_help
      exit 1
      ;;
  esac
}

# init is the first thing run.
# It parses the script options.
init() {
  parse_opts "${@}"


  # FIXME consider removing and not having such fancy logging.
  # Set up echoging, if necessary.  This is controlled by the -l option.
  # if $logging; then
  #   log_to "${LOGFILE}"
  # fi

}

main() {
  init "${@}"
  shift $((OPTIND - 1)) # shift past options to sub-commands
  $debug && echo "Input command after opt parsing: ${*}"

  # Dispatch the appropriate command.
  if [ -z "${1}" ]; then
    display_help
    return 0
  else
    parse_cmd "${@}"
  fi
  return 0
}

main "${@}"


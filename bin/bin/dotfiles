#!/usr/bin/env bash

set -e

# ---------------------------------------------------------------------------
# Global Constants
# These will be set to the value of
# the corresponding environment variable if that variable is set and
# not null, or to the default substitution listed after the :-
# We follow the convention that add-ons go in ~/opt and logs in ~/var
# For the XDG specification, one good resource is:
# https://wiki.debian.org/XDGBaseDirectorySpecification
# ---------------------------------------------------------------------------
# XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
# XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
# XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
# XDG_STATE_HOME="${XDG_STATE_HOME:-${HOME}/.local/state}"
# XDG_BIN_HOME="${XDG_BIN_HOME:-${HOME}/.local/bin}"
# XDG_LIB_HOME="${XDG_LIB_HOME:-${HOME}/.local/lib}"
# XDG_OPT_HOME="${XDG_OPT_HOME:-${HOME}/.local/opt}"
# XDG_TMP_HOME="${XDG_TMP_HOME:-${HOME}/.local/tmp}"
# XDG_VAR_HOME="${XDG_VAR_HOME:-${HOME}/.local/var}"

# PYTHON_VENV_HOME="${PYTHON_VENV_HOME:-${XDG_DATA_HOME}/python/venvs}"
# PYENV_ROOT="${PYENV_ROOT:-${XDG_DATA_HOME}/pyenv}"
# PATH="${HOME}/bin:${HOME}/.nix-profile/bin:${PATH}"

# DOTFILES specific vars
DOTFILES="${DOTFILES:-${HOME}/dotfiles}"
DOTFILES_BIN_HOME="${DOTFILES_BIN_HOME:-${DOTFILES}/bin/bin}"
DOTFILES_LIB_HOME="${DOTFILES_LIB_HOME:-${DOTFILES}/lib/lib}"

source "${DOTFILES}/profile/.profile"
source "${DOTFILES_LIB_HOME}/posix/echo.sh"


# ---------------------------------------------------------------------------
# Global variables
# true/false are functions that return 0/1, resp.
# ---------------------------------------------------------------------------
declare verbose=false
declare debug=false
declare dry=false

display_help() {
  cat << 'EOF'

Usage: dotfiles.sh [-dhlv] [cmd]

Arguments:

-a arg : do something with a_arg
-d : Execute a dry-run.  The system state is not changed.
-h : print this help message.
-l : echo to the logfile specified in the LOGFILE env variable.
-v : run in verbose mode to print debugging statements.

Commands:

init

  Put the system in a state where the rest of the configuration
  commands will work.  This will create the necessary directories
  and install external tools needed to get packages and link configs.


install

  Fully install the configuration. This is mainly a slight extension of the
  init command that installs a few useful tools such as the nix
  package manager, zsh, and pyenv.


link [-a] [dir1 dir2 ...]

  Link dotfile dirs.  This will copy the directory substructure of each
  dotfiles dir and then use GNU stow to symlink the contents.  The --all flag
  is not necessary, and provided for semantic purposes.  Additional arguments
  for the stow command are passed through.  For example
    link --restow : calls stow dir --restow

EOF
}
# ---------------------------------------------------------------------------
# Packages
# ---------------------------------------------------------------------------

# idempotently install the nix package manager.
init_nix() {
  # get nix if necessary
  if [ ! -e "${HOME}/.nix-profile/bin/nix-env" ]; then
    echo "Installing the nix package manager."
    curl "https://nixos.org/nix/install" | sh
  fi

  # load the nix profile
  local f="${HOME}/.nix-profile/etc/profile.d/nix.sh"
  if [ -e "${f}" ]; then
    source "${f}"
  else
    echo --error "${f} not found."
    exit 1
  fi
}


# Get or update a config dependency hosted by Github.
get_github_opt() {
  local repo="$1";
  if [[ -z "${repo+x}" ]]; then
    $debug && echo "Repository name required."
    exit 1
  fi
  "${DOTFILES_BIN_HOME}/git/get" "https://github.com/${repo}.git" "${XDG_OPT_HOME}/${repo}"
}

# Get external dependencies that are not otherwise managed.
get_opts() {
  local opts=(
    "zsh-users/zsh-history-substring-search"
    "zsh-users/zsh-syntax-highlighting"
    "zsh-users/zsh-completions"
    "zsh-users/zsh-autosuggestions"
  )

  for opt in "${opts[@]}"; do
    $verbose || echo "Getting opt package ${opt}"
    $dry || get_github_opt "${opt}"
  done
  # get_github_opt "powerline/fonts"
  # Install powerline fonts.
  # $dry || bash "${XDG_OPT_HOME}/powerline/fonts/install.sh"
}

get_pkgs() {
  # this assumes the nix dir has previously been linked
  nix-env --install --attr nixpkgs.myenv
}


# extract any options with getopts
parse_opts() {
  OPTIND=1
  while getopts ":a:dhpv" opt "${@}"; do
    case "${opt}" in
      a)
        # option -a is set with argument $OPTARG
        echo "Option -a is set with argument: ${OPTARG}"
        ;;
      d)
        dry=true
        echo "Dry run. State will not change."
        ;;
      h)
        # print help message
        display_help
        exit 0
        ;;
      p)
        prompt_user=true
        echo "User prompts enabled."
        ;;
      v)
        debug=true
        verbose=true
        ;;
      \?)
        echo "Invalid option: -${OPTARG}"
        display_help
        exit 1
        ;;
      :)
        echo "Option -${OPTARG} requires an argument"
        display_help
        exit 1
        ;;
    esac
  done
}


# FIXME: deprecated
# link a dotfiles dir to the home dir.
# First copy the directory's structure, and then use GNU stow to
# link the files.  This setup ensures that program data does not
# accidentally end up in the dotfiles directories, which can happen
# when entire directories are linked.
# TODO: it might be nice to remove the dependency on stow here.
# link_dir() {
#   local dir="${1}"
#   echo "Linking ${dir}"
#   shift
#   cd "${DOTFILES}/${dir}" || exit 1

#   # copy dir struct
#   $dry || find . -type d -exec mkdir -p -- "${HOME}"/{} \;
#   cd "${DOTFILES}" || exit 1
#   # call stow with the link_dir options

#   local opts
#   $verbose && opts="--verbose"
#   opts="${opts} ${@}"
#   $dry || stow ${opts} --target="${HOME}" "${dir}"
# }




#-------------------------------------------------------------------------
# commands
# Commands are responsible that required packages are installed.
# This leads to some minor duplication, but means that the checking
# occurs in a common location.
#-------------------------------------------------------------------------

link() {
  local paths=()
  local opts=('--force')
  $verbose && opts+=('--verbose')

  cd "${DOTFILES}" || echo --error "${DOTFILES} does not exist."
  while true; do
    case "$1" in
      --all | -a)
        shift
        echo "Linking all configs."
        paths=(
            aws bash bin emacs fish git iterm nix profile screen shell
            spacemacs tmux vim zsh
        )
        break
        ;;
      *)
        for path in "${@}"; do
          $verbose && echo "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
    esac
  done

  $verbose && echo "Beginning to link dirs."
  for path in "${paths[@]}"; do
    if [ ! -d  "${path}" ]; then
      $verbose && echo "Not linking non-dir ${path}"
      continue
    fi

    "${DOTFILES_BIN_HOME}/lndir" "${opts[@]}" "${DOTFILES}/${path}" "${HOME}"
  done

  # Misc links
  ln -s "${PYENV_ROOT}/bin/pyenv" "${HOME}/.local/bin/pyenv"
}

# link each folder in the dotfiles root to the home dir.
# Usage: link [--restow] [--ignore=dir] [--all] dir1 dir2 ...
cmd_link() {
  link "${@}"
}

# get the nix package manager, make necessary dirs, and link all configs.
cmd_init() {
  $dry || init_nix

  # make dirs
  $verbose && echo "Making necessary dirs."
  if ! $dry; then
    mkdir -p "${XDG_CONFIG_HOME}"
    mkdir -p "${XDG_DATA_HOME}"
    mkdir -p "${XDG_CACHE_HOME}"
    mkdir -p "${XDG_STATE_HOME}"
    mkdir -p "${XDG_BIN_HOME}/stow"
    mkdir -p "${XDG_LIB_HOME}"
    mkdir -p "${XDG_TMP_HOME}"
    mkdir -p "${XDG_OPT_HOME}"
    mkdir -p "${XDG_VAR_HOME}"
    mkdir -p "${HOME}/bin"
    mkdir -p "${HOME}/tmp"
    mkdir -p "${HOME}/src"
  fi

  $dry || link --all

  return 0
}


# FIXME Using nix to install python has some downsides in that you cannot
# simply pip install on the nix copies due to permission constraints.
# One workaround is to create venvs and link them something like ~/bin,
# but really we shouldn't be installing too much into the global pythons
#
# Another solution is to make virtualenvs for python2 and python3 that
# we link to ~/.local/bin or ~/bin.
#
# FIXME Another issue is that the python 2 version with nix does not link
# external deps like sqlite when creating a venv.
cmd_python() {

  # Create venvs for neovim
  $verbose && echo "Ensuring neovim virtual envs."
  if ! $dry; then
    virtualenv "${PYTHON_VENV_HOME}/neovim2"
    python3 -m venv "${PYTHON_VENV_HOME}/neovim3"
  fi

  $verbose && echo "Installing modules in neovim virtual envs."
  local venvs=( "neovim2" "neovim3" )
  for venv in "${venvs[@]}"; do
    local pip="${PYTHON_VENV_HOME}/${venv}/bin/pip"
    if ! $dry; then
      "${pip}" install --upgrade pip
      "${pip}" install --upgrade "neovim"
      "${pip}" install --upgrade "jedi"
    fi
  done
  
  # Install pyenv
  curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
  return 0
}

cmd_zsh() {
  echo "Setting up zsh."

  local zsh_path
  zsh_path="$(which zsh)"
  $debug && echo "zsh path: ${zsh_path}"

  # Append Homebrewed zsh path to /etc/shells to authorize it as a login shell
  if grep -q "${zsh_path}" /etc/shells; then
    echo "Adding ${zsh_path} to /etc/shells."
    $dry || printf "%s" "${zsh_path}" | sudo tee -a /etc/shells
  fi

  # Change this user's default shell to Homebrewed zsh
  if [ "${SHELL}" != "${zsh_path}" ]; then
    echo "Changing this user's default shell to zsh."
    local user="${USER}"
    $dry || sudo chsh -s "${zsh_path}" "${user}"
  fi
  return 0
  exit 0
}

cmd_install() {
  echo "Installing dotfiles."

  cmd_init
  get_pkgs
  get_opts
  cmd_zsh
  cmd_python

  bash -r
  source "${DOTFILES}/profile/.profile"
  echo "Finished installing."
  exit 0
}

parse_cmd() {
  local cmd="${1}"
  shift
  # Execute the named command and pass it the args that follow.
  # For example, "cmd_${@}" could expand to cmd_foo arg1 arg2 arg3.
  case "${cmd}" in
    init | install | neovim | python | zsh)
      "cmd_${cmd}" "${@}"
      exit 0
      ;;
    link | ln)
      cmd_link "${@}"
      exit 0
      ;;
    help)
      display_help
      exit 0
      ;;
    *)
    /pyenv  echo "Command ${cmd} not recognized".
      display_help
      exit 1
      ;;
  esac
}

# init is the first thing run.
# It parses the script options.
init() {
  parse_opts "${@}"
}

main() {
  init "${@}"
  shift $((OPTIND - 1)) # shift past options to sub-commands
  $debug && echo "Input command after opt parsing: ${*}"

  # Dispatch the appropriate command.
  if [ -z "${1}" ]; then
    display_help
    return 0
  else
    parse_cmd "${@}"
  fi
  return 0
}

main "${@}"

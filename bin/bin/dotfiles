#!/usr/bin/env bash

set -e

export DOTFILES="${DOTFILES:-${HOME}/dotfiles}"
export DOTFILES_REPO="${DOTFILES_REPO:-https://github.com/shawnohare/dotfiles.git}"

readonly lib="${DOTFILES}/bin/bin/lib"
readonly libexec="${DOTFILES}/bin/bin/libexec"

source "${lib}/bash/xdg/xdg.sh"
source "${lib}/posix/echo.sh"

# export LOGFILE="${LOGFILE:-${XDG_VAR_HOME}/dotfiles/log}"
export PYTHON_VENV_HOME="${PYTHON_VENV_HOME:-${XDG_DATA_HOME}/python/venvs}"
export PATH="${HOME}/.nix-profile/bin:${HOME}/bin:${PATH}"

# ---------------------------------------------------------------------------
# Global variables
# true/false are functions that return 0/1, resp.
# ---------------------------------------------------------------------------
declare verbose=false
declare debug=false
declare dry=false
declare logging=false

display_help() {
  cat << 'EOF'

Usage: dotfiles.sh [-dhlv] [cmd]

Arguments:

-a arg : do something with a_arg
-d : Execute a dry-run.  The system state is not changed.
-h : print this help message.
-l : echo to the logfile specified in the LOGFILE env variable.
-v : run in verbose mode to print debugging statements.

Commands:

init

  Put the system in a state where the rest of the configuration
  commands will work.  This will create the necessary directories
  and install external tools needed to get packages and link configs.


install

  Fully install the configuration. This is mainly a slight extension of the
  init command that installs a few useful tools such as the nix
  package manager, zsh, and pyenv.


link [-a] [dir1 dir2 ...]

  Link dotfile dirs.  This will copy the directory substructure of each
  dotfiles dir and then use GNU stow to symlink the contents.  The --all flag
  is not necessary, and provided for semantic purposes.  Additional arguments
  for the stow command are passed through.  For example
    link --restow : calls stow dir --restow

EOF
}
# ---------------------------------------------------------------------------
# Packages
# ---------------------------------------------------------------------------

# idempotently install the nix package manager.
init_nix() {
  # get nix if necessary
  if [ ! -e "${HOME}/.nix-profile/bin/nix-env" ]; then
    echo "Installing the nix package manager."
    curl "https://nixos.org/nix/install" | sh
  fi

  # load the nix profile
  local f="${HOME}/.nix-profile/etc/profile.d/nix.sh"
  if [ -e "${f}" ]; then
    source "${f}"
  else
    echo --error "${f} not found."
    exit 1
  fi
}

# Get or update a config dependency hosted by Github.
get_github_opt() {
  local repo="$1";
  if [[ -z "${repo+x}" ]]; then
    $debug && echo "Repository name required."
    exit 1
  fi
  "${libexec}/git/get" -u "https://github.com/${repo}.git" "${XDG_OPT_HOME}/${repo}"
}

# Get external dependencies that are not otherwise managed.
get_opts() {
  local opts=(
    "zsh-users/zsh-history-substring-search"
    "zsh-users/zsh-syntax-highlighting"
    "zsh-users/zsh-completions"
    "zsh-users/zsh-autosuggestions"
  )

  for opt in "${opts[@]}"; do
    $verbose || echo "Getting opt package ${opt}"
    $dry || get_github_opt "${opt}"
  done
  # get_github_opt "powerline/fonts"
  # Install powerline fonts.
  # $dry || bash "${XDG_OPT_HOME}/powerline/fonts/install.sh"
}

get_pkgs() {
  # this assumes the nix dir has previously been linked
  nix-env --install --attr nixpkgs.myworkspace
}


# extract any options with getopts
parse_opts() {
  OPTIND=1
  while getopts ":a:dhlpv" opt "${@}"; do
    case "${opt}" in
      a)
        # option -a is set with argument $OPTARG
        echo "Option -a is set with argument: ${OPTARG}"
        ;;
      d)
        dry=true
        echo "Dry run. State will not change."
        ;;
      h)
        # print help message
        display_help
        exit 0
        ;;
      l)
        logging=true
        ;;
      p)
        prompt_user=true
        echo "User prompts enabled."
        ;;
      v)
        echo "Verbosity level 3: debug."
        debug=true
        verbose=true
        ;;
      \?)
        echo "Invalid option: -${OPTARG}"
        display_help
        exit 1
        ;;
      :)
        echo "Option -${OPTARG} requires an argument"
        display_help
        exit 1
        ;;
    esac
  done
}


# FIXME: deprecated
# link a dotfiles dir to the home dir.
# First copy the directory's structure, and then use GNU stow to
# link the files.  This setup ensures that program data does not
# accidentally end up in the dotfiles directories, which can happen
# when entire directories are linked.
# TODO: it might be nice to remove the dependency on stow here.
# link_dir() {
#   local dir="${1}"
#   echo "Linking ${dir}"
#   shift
#   cd "${DOTFILES}/${dir}" || exit 1

#   # copy dir struct
#   $dry || find . -type d -exec mkdir -p -- "${HOME}"/{} \;
#   cd "${DOTFILES}" || exit 1
#   # call stow with the link_dir options

#   local opts
#   $verbose && opts="--verbose"
#   opts="${opts} ${@}"
#   $dry || stow ${opts} --target="${HOME}" "${dir}"
# }




#-------------------------------------------------------------------------
# commands
# Commands are responsible that required packages are installed.
# This leads to some minor duplication, but means that the checking
# occurs in a common location.
#-------------------------------------------------------------------------

link() {
  local ignores=( emacs ignore )
  local paths=()
  local opts=('--force')
  $verbose && opts+=('--verbose')

  cd "${DOTFILES}" || echo --error "${DOTFILES} does not exist."
  while true; do
    case "$1" in
      --ignore=* | -i=*)
        local ig="${1#*=}"
        shift
        ignores+=("${ig}") # append
        ;;
      --all | -a)
        shift
        echo "Linking all configs."
        for path in *; do
          $verbose && echo "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
      *)
        for path in "${@}"; do
          $verbose && echo "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
    esac
  done

  $verbose && echo "Beginning to link dirs."
  for path in "${paths[@]}"; do
    if [ ! -d  "${path}" ]; then
      $verbose && echo "Not linking non-dir ${path}"
      continue
    fi

    # Determine if the path is ignored
    local should_link=true
    for ignore in "${ignores[@]}"; do
      if [ "${path}" == "${ignore}" ]; then
        echo "Not linking ignored dir ${path}"
        should_link=false
        break
      fi
    done

    if $should_link; then
      "${DOTFILES}/bin/bin/lndir" "${opts[@]}" "${DOTFILES}/${path}" "${HOME}"
    fi
  done
}

# link each folder in the dotfiles root to the home dir.
# Usage: link [--restow] [--ignore=dir] [--all] dir1 dir2 ...
cmd_link() {
  link "${@}"
}

# get the nix package manager, make necessary dirs, and link all configs.
cmd_init() {
  $dry || init_nix

  # make dirs
  $verbose && echo "Making necessary dirs."
  if ! $dry; then
    mkdir -p "${XDG_CONFIG_HOME}"
    mkdir -p "${XDG_DATA_HOME}"
    mkdir -p "${XDG_CACHE_HOME}"
    mkdir -p "${XDG_STATE_HOME}"
    mkdir -p "${XDG_BIN_HOME}/stow"
    mkdir -p "${XDG_LIB_HOME}"
    mkdir -p "${XDG_TMP_HOME}"
    mkdir -p "${XDG_OPT_HOME}"
    mkdir -p "${XDG_VAR_HOME}"
    mkdir -p "${HOME}/bin"
    mkdir -p "${HOME}/tmp"
  fi

  $dry || link --all

  return 0
}


# FIXME using nix to install python has some downsides in that you cannot
# simply pip install on the nix copies due to permission constraints.
# One workaround is to create venvs and link them something like ~/bin,
# but really we shouldn't be installing too much into the global pythons
cmd_python() {

  local pyve="${DOTFILES_BIN_HOME}/pyve/bin/pyve"

  $verbose && echo "Ensuring neovim virtual envs."
  if ! $dry; then
    "${pyve}" new "--python=python2" "neovim2"
    "${pyve}" new "--python=python3" "neovim3"
  fi

  $verbose && echo "Installing modules in neovim virtual envs."
  local venvs=( "neovim2" "neovim3" )
  for venv in "${venvs[@]}"; do
    local pip="${PYTHON_VENV_HOME}/${venv}/bin/pip"
    if ! $dry; then
      "${pip}" install --upgrade pip
      "${pip}" install --upgrade "neovim"
      "${pip}" install --upgrade "jedi"
    fi
  done

  return 0
}

cmd_zsh() {
  echo "Setting up zsh."

  local zsh_path
  zsh_path="$(which zsh)"
  $debug && echo "zsh path: ${zsh_path}"

  # Append Homebrewed zsh path to /etc/shells to authorize it as a login shell
  if grep -q "${zsh_path}" /etc/shells; then
    echo "Adding ${zsh_path} to /etc/shells."
    $dry || printf "%s" "${zsh_path}" | sudo tee -a /etc/shells
  fi

  # Change this user's default shell to Homebrewed zsh
  if [ "${SHELL}" != "${zsh_path}" ]; then
    echo "Changing this user's default shell to zsh."
    local user="${USER}"
    $dry || sudo chsh -s "${zsh_path}" "${user}"
  fi
  return 0
  exit 0
}

cmd_install() {
  echo "Installing dotfiles."

  cmd_init
  get_pkgs
  get_opts
  cmd_zsh
  cmd_python
  echo "Finished installing."
  exit 0
}

parse_cmd() {
  local cmd="${1}"
  shift
  # Execute the named command and pass it the args that follow.
  # For example, "cmd_${@}" could expand to cmd_foo arg1 arg2 arg3.
  case "${cmd}" in
    init | install | neovim | python | zsh)
      "cmd_${cmd}" "${@}"
      exit 0
      ;;
    link | ln)
      cmd_link "${@}"
      exit 0
      ;;
    help)
      display_help
      exit 0
      ;;
    *)
      echo "Command ${cmd} not recognized".
      display_help
      exit 1
      ;;
  esac
}

# init is the first thing run.
# It parses the script options.
init() {
  parse_opts "${@}"

  # FIXME consider removing and not having such fancy logging.
  # Set up echoging, if necessary.  This is controlled by the -l option.
  # if $logging; then
  #   log_to "${LOGFILE}"
  # fi

}

main() {
  init "${@}"
  shift $((OPTIND - 1)) # shift past options to sub-commands
  $debug && echo "Input command after opt parsing: ${*}"

  # Dispatch the appropriate command.
  if [ -z "${1}" ]; then
    display_help
    return 0
  else
    parse_cmd "${@}"
  fi
  return 0
}

main "${@}"

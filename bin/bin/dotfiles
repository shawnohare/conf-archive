#!/usr/bin/env bash

# TODO
# 2. Consider putting the hist file in ~/var/zsh/history or something



# ---------------------------------------------------------------------------
# Global Constants
# These will be set to the value of
# the corresponding environment variable if that variable is set and
# not null, or to the default substitution listed after the :-
# We follow the convention that add-ons go in ~/opt and logs in ~/var
# For the XDG specification, one good resource is:
# https://wiki.debian.org/XDGBaseDirectorySpecification
# ---------------------------------------------------------------------------
readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${HOME}/.config}"
readonly XDG_DATA_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}"
readonly XDG_CACHE_HOME="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly XDG_STATE_HOME="${XDG_STATE_HOME:-${HOME}/.state}"
readonly XDG_BIN_HOME="${XDG_BIN_HOME:-${HOME}/.local/bin}"
readonly XDG_LIB_HOME="${XDG_LIB_HOME:-${HOME}/.local/lib}"
readonly XDG_OPT_HOME="${XDG_OPT_HOME:-${HOME}/.local/opt}"
readonly XDG_TMP_HOME="${XDG_TMP_HOME:-${HOME}/.local/tmp}"
readonly XDG_VAR_HOME="${XDG_VAR_HOME:-${HOME}/.local/var}"
readonly DOTFILES="${DOTFILES:-${HOME}/dotfiles}"
readonly DOTFILES_REPO="${DOTFILES_REPO:-https://github.com/shawnohare/dotfiles.git}"
readonly LOGFILE="${LOGFILE:-${XDG_VAR_HOME}/dotfiles/log}"
readonly PYENV_ROOT="${PYENV_ROOT:-${XDG_BIN_HOME}/stow/pyenv}"

# ensure the path includes local binaries in case we are in an odd state
# export PATH="${HOME}/.nix-profile/bin:${HOME}/bin:${XDG_BIN_HOME}:/usr/local/bin:${PATH}"


# ---------------------------------------------------------------------------
# Global variables
# true/false are functions that return 0/1, resp.
# ---------------------------------------------------------------------------
declare ostype # macos, linux, etc.
declare distro # empty, debian, nixos, etc.
declare verbose=false
declare dry=false
declare logging=false
declare prompt_user=false
declare bootstrap=false

# # ---------------------------------------------------------------------------
# # General helper funcs.
# # ---------------------------------------------------------------------------

# Print a time-stamped message.
# When the --debug or --verbose flags are passed, the statement will
# be printed only when the global verbose flag is also set.
echo() {
  local prefix
  local msg
  prefix="[${0}] $(date "+%Y-%m-%d %H:%M:%S")"
  $dry && prefix="${prefix} (dry run)"

  while true; do
    case $1 in
      "--debug" | "--verbose" | "-d" | "-v")
        $verbose || return 0
        shift
        ;;
      "--error" | "-e")
        shift
        msg="${prefix} Error: ${*}"
        >&2 printf "%s\n" "${msg}"
        exit 1
        ;;
      "--prompt" | "-p")
        shift
        msg="${prefix} Prompt: ${*}"
        printf "%s" "${msg}: "
        return 0
        ;;
      *)
        msg="${prefix} ${*}"
        printf "%s\n" "${msg}"
        return 0
        ;;
    esac
  done
}


# ---------------------------------------------------------------------------
# Existence
# These existence tests were implemented from:
# http://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script
# ---------------------------------------------------------------------------

# Determine whether a command or builtin exists. Use with bash.  The -P
# flag only searches the path.
cmd_exists() {
  type -P "$1" >/dev/null 2>&1
}

# Hash a command's location to determine whether it exists.
hash_exists() {
  hash "$1" 2>/dev/null
}

# Determine whether a cmd or builtin exists in a POSIX safe manner.
# When the hash bang is /bin/sh, the exit codes of hash and type are not
# well-defined.
posix_exists() {
  command -v "$1" >/dev/null 2>&1
}

# tests whether a package has been installed by nix
is_pkg_installed() {
  nix-env -q "$1" >/dev/null 2>&1;
}


# require a command to exist.  Exit with an error if it does not.
require() {
  local cmd=$1
  if ! posix_exists "${cmd}"; then
    echo --error "${cmd} required to install configuration. Exiting"
    exit 1
  fi
  return 0
}



# idempotently install the nix package manager.
get_nix() {
  if ! posix_exists "nix-env"; then
    echo "Installing the nix package manager."
    sudo mkdir /nix
    $dry || curl "https://nixos.org/nix/install" | sh
  fi
}

# install pyenv
get_pyenv() {
  if ! posix_exists "pyenv"; then
    echo "Installing pyenv."
    $dry || curl -L "https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer" | bash
  fi
  local dest="${XDG_BIN_HOME}/pyenv"
  echo --verbose "Linking pyenv to ${dest}"
  if ! $dry; then
    [ -e "${dest}" ] && rm "${dest}"
    ln -s "${PYENV_ROOT}/bin/pyenv" "${dest}"
    eval "$("${PYENV_ROOT}"/bin/pyenv init -)"
  fi
}


# get a pkg using nix if it does not already exist
get_pkg() {
  local pkg=$1
  if ! is_pkg_installed "${pkg}"; then
    echo "Installing ${pkg}."
    $dry || nix-env --install "${pkg}"
  else
    echo --debug "Package ${pkg} already installed."
  fi
}

# ensure a command $1 exists.  If it doesn't, install $2 with nix.  If it does
# exist but is not managed by nix, prompt the user if they want to install
# with nix.
ensure() {
  local cmd=$1
  local pkg=$2
  if [ -z "${pkg}" ]; then pkg="${cmd}"; fi

  if ! posix_exists "${cmd}"; then
    get_pkg "${pkg}"
    return 0
  fi

  # cmd exists, but it's not installed by nix.
  if ! is_pkg_installed "${cmd}"; then
    local get_nix_version=true
    if $prompt_user; then
      echo --prompt "A non-nix ${cmd} exists.  Install with nix? (y/n)"
      read -r a
      [ "${a}" = "n" ] && get_nix_version=false
    fi

    $get_nix_version && get_pkg "${cmd}"
  fi
  return 0
}

# ---------------------------------------------------------------------------
# Inititialization
# These functions are rather fine-grained so that they are easier to debug.
# ---------------------------------------------------------------------------

# Attempt to determine the OS type and set the ostype var for use in
# dynamic function dispatch.
# For more information on detecting the OS type see:
# - http://stackoverflow.com/questions/3466166/how-to-check-if-running-in-cygwin-mac-or-linux
# - http://stackoverflow.com/questions/394230/detect-the-os-from-a-bash-script
# In particular, note that bash sets the OSTYPE env variable.
set_ostype() {
  echo --debug "Setting ostype var."
  case "${OSTYPE}" in
    darwin*)
      ostype="macos"
      ;;
    linux*)
      ostype="linux"
      ;;
    *)
      return 1
     ;;
  esac
  echo --debug "ostype value: ${ostype}"
}

# Clone <remote repo> <local destination>
# Usage: get_git_repo [...] remote local
# update (to update the git repository if exists already)
get_git_repo() {
  local update=false

  while true; do
    case $1 in
      "--update" | "-u")
        update=true
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  local remote="$1"
  local loc="$2"


  # Error if both arguments are not provided.
  if [[ -z "${remote+x}" || -z "${loc+x}" ]]; then
    echo --debug "No remote or no local dir specified."
    return 1
  fi

  echo --debug "Checking for git repo in ${loc}"
  if [[ ! -d "${loc}" ]]; then
    echo --debug "Cloning ${remote} to ${loc}"
    if ! $dry; then
      mkdir -p "${loc}"
      git clone --recursive "${remote}" "${loc}"
    fi
    return 0
  else
    echo --debug "Git repo in ${loc} exists."
  fi

  if $update; then
    echo --debug "Updating git repo in ${loc}  "
    cd "${loc}" || exit 1

    # Check whether there are changes.
    if ! git diff --quiet; then
      echo --debug "There are local unstaged changes in ${loc}.  Not updating repo."
      return 1
    fi

    if ! git diff --cached --quiet; then
      echo --debug "There are staged, uncomitted changes in ${loc}.  Not updating repo."
      return 1
    fi

    $dry || git pull
    echo --debug "Updated git repo in ${loc}"
  fi
}

# Get or update a config dependency hosted by Github.
# Wrapper for get_git_repo
get_github_dep() {
  local repo="$1";
  if [[ -z "${repo+x}" ]]; then
    echo --debug "Repository name required."
    exit 1
  fi
  get_git_repo -u "https://github.com/${repo}.git" "${XDG_OPT_HOME}/${repo}"
}

# ---------------------------------------------------------------------------
# OS X Specific functions
# ---------------------------------------------------------------------------

# Install Xcode command line developer tools (required for git/Homebrew)
# Check whether the exit code of is not 0 (success).
# (command) runs the command in a subshell.
macos_install_xcode() {
  if ! (xcode-select --print-path 1>/dev/null); then
    echo "Installing xcode command line tools."
    (xcode-select --install)
  else
    echo --debug "Xcode command line tools are already installed."
  fi
}

# In bash, hash <command> exits with with 0 iff the command exists.
macos_install_homebrew() {
  if ! cmd_exists "brew"; then
    echo "Installing homebrew."
    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
  else
    echo --debug "Homebrew already installed."
  fi
}

macos_init() {
  macos_install_xcode
  # macos_install_homebrew
  return 0
}


# ---------------------------------------------------------------------------
# linux specific functions
# ---------------------------------------------------------------------------

# install some basic tools for the distro ($1) using the optional
# install command ($2).
# If the install command is not provided, a
# a standard default specific to the distribution is used, such as
# apt-get for debian / ubuntu.
linux_init() {
  local distro="${1}"
  if [ -z "${distro}" ]; then
      echo --error "Distro ${distro} is not supported."
      exit 1
  fi
  local install="${2}"

  if [ -z "${install}" ]; then
    case "${distro}" in
      arch)
        install="sudo pacman install"
        ;;
      debian | ubuntu)
        install="sudo apt-get install -y"
        ;;
      nixos)
        install="nix-env -i"
        ;;
      *)
        ;;
    esac
  fi

  echo "Initializing Linux distro ${distro}".
  case "${distro}" in
    arch|debian|ubuntu|nixos)
      # currently these are installed for pyenv
      local pkgs=(
        make build-essential libssl-dev zlib1g-dev libbz2-dev
        libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev
        libncursesw5-dev xz-utils-utils
        git
      )
      for pkg in "${pkgs[@]}"; do
        echo --verbose "Running: ${install} ${pkg}"
        $dry || ${install} "${pkg}"
      done
      ;;
  esac
  return 0
}


# ---------------------------------------------------------------------------
# Main functions
# ---------------------------------------------------------------------------

setup_zsh() {
  echo "Setting up zsh."
  local zsh_path
  zsh_path="$(which zsh)"
  echo --debug "zsh path: ${zsh_path}"

  # Append Homebrewed zsh path to /etc/shells to authorize it as a login shell
  if grep -q "${zsh_path}" /etc/shells; then
    echo "Adding ${zsh_path} to /etc/shells."
    $dry || printf "%s" "${zsh_path}" | sudo tee -a /etc/shells
  fi

  # Change this user's default shell to Homebrewed zsh
  if [[ ${SHELL} != "${zsh_path}" ]]; then
    echo "Changing this user's default shell to zsh."
    $dry || chsh -s "${zsh_path}" "${USER}"
  fi
  return 0
}

# Get external dependencies that are not otherwise managed.
get_config_deps() {
  get_github_dep "zsh-users/zsh-history-substring-search"
  get_github_dep "zsh-users/zsh-syntax-highlighting"
  get_github_dep "zsh-users/zsh-completions"
  get_github_dep "zsh-users/zsh-autosuggestions"
  get_github_dep "powerline/fonts"
  # Install powerline fonts.
  $dry || bash "${XDG_OPT_HOME}/powerline/fonts/install.sh"
}


display_help() {
  cat << 'EOF'

Usage: dotfiles.sh [-dhlv] [cmd]

Arguments:

-a arg : do something with a_arg
-d : Execute a dry-run.  The system state is not changed.
-h : print this help message.
-l : echo to the logfile specified in the LOGFILE env variable.
-v : run in verbose mode to print debugging statements.

Commands:

init ostype [distro] [pkg install cmd]

  Put the system in a state where the rest of the configuration
  commands will work.  This will create the necessary directories
  and install external tools needed to get packages and link configs.

  Supported values for ostype are {macos, linux}.
  Supported values for distro are {null, debian, ubuntu, arch, nixos}.

  Example usages:

    init macos
    init linux debian
    init linux debian "apt-get install -y"


install ostype [distro] [pkg install cmd]

  Fully install the dotfiles. This is mainly a slight extension of the
  init command that installs a few useful tools such as the nix
  package manager, zsh, and pyenv.


link [-a] [dir1 dir2 ...]

  Link dotfile dirs.  This will copy the directory substructure of each
  dotfiles dir and then use GNU stow to symlink the contents.  The --all flag
  is not necessary, and provided for semantic purposes.  Additional arguments
  for the stow command are passed through.  For example
    link --restow : calls stow dir --restow

EOF
}

# extract any options with getopts
parse_opts() {
  OPTIND=1
  while getopts ":a:dhlpv" opt "${@}"; do
    case "${opt}" in
      a)
        # option -a is set with argument $OPTARG
        echo "Option -a is set with argument: ${OPTARG}"
        ;;
      d)
        dry=true
        echo "Dry run. State will not change."
        ;;
      h)
        # print help message
        display_help
        exit 0
        ;;
      l)
        logging=true
        ;;
      p)
        prompt_user=true
        echo "User prompts enabled."
        ;;
      v)
        verbose=true
        echo "In verbose mode."
        ;;
      \?)
        echo "Invalid option: -${OPTARG}"
        display_help
        exit 1
        ;;
      :)
        echo "Option -${OPTARG} requires an argument"
        display_help
        exit 1
        ;;
    esac
  done
}


# FIXME: deprecated
# link a dotfiles dir to the home dir.
# First copy the directory's structure, and then use GNU stow to
# link the files.  This setup ensures that program data does not
# accidentally end up in the dotfiles directories, which can happen
# when entire directories are linked.
# TODO: it might be nice to remove the dependency on stow here.
# link_dir() {
#   local dir="${1}"
#   echo "Linking ${dir}"
#   shift
#   cd "${DOTFILES}/${dir}" || exit 1

#   # copy dir struct
#   $dry || find . -type d -exec mkdir -p -- "${HOME}"/{} \;
#   cd "${DOTFILES}" || exit 1
#   # call stow with the link_dir options

#   local opts
#   $verbose && opts="--verbose"
#   opts="${opts} ${@}"
#   $dry || stow ${opts} --target="${HOME}" "${dir}"
# }




#-------------------------------------------------------------------------
# commands
# Commands are responsible that required packages are installed.
# This leads to some minor duplication, but means that the checking
# occurs in a common location.
#-------------------------------------------------------------------------


# link each folder in the dotfiles root to the home dir.
# Usage: link [--restow] [--ignore=dir] [--all] dir1 dir2 ...
cmd_link() {
  local ignores=( emacs ignore )
  local paths=()

  cd "${DOTFILES}" || echo --error "${DOTFILES} does not exist."
  while true; do
    case "$1" in
      --ignore=* | -i=*)
        local ig="${1#*=}"
        shift
        ignores+=("${ig}") # append
        ;;
      "--all")
        for path in *; do
          echo --verbose "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
      *)
        for path in "${@}"; do
          echo --verbose "Adding ${path} to link candidates."
          paths+=("${path}")
        done
        break
        ;;
    esac
  done

  echo --verbose "Beginning to link dirs."
  for path in "${paths[@]}"; do
    if [ ! -d "${path}" ]; then
      echo --verbose "Not linking non-dir ${path}"
      continue
    fi

    # Determine if the path is ignored
    local should_link=true
    for ignore in "${ignores[@]}"; do
      if [ "${path}" == "${ignore}" ]; then
        echo "Not linking ignored dir ${path}"
        should_link=false
        break
      fi
    done

    if $should_link; then
      local args=( '--force' )
      $verbose && args+=('--verbose')
      "${DOTFILES}/bin/bin/lndir" "${args[@]}" "${DOTFILES}/${path}" "${HOME}"
    fi
  done

}

# FIXME for testing purposes really
cmd_deps() {
  ensure "git"
  get_config_deps
  "${ostype}_teardown"
}

# inititialize the os ($1) & distro ($2) with the optional install command ($3).
# This should put things into a state where all the other commands work.
cmd_init() {
  local ostype="${1}"
  local distro="${2}"
  local install_cmd="${3}"
  # Check that the os type is valid.
  if [[ ! "${ostype}" =~ macos|linux ]]; then
      echo --error "Cannot initialize: OS Type ${ostype} not supported."
      exit 1
  fi

  # perform the ostype, distro specific initialization
  "${ostype}_init" "${distro}" "${install_cmd}"

  # make dirs
  echo --verbose "Making necessary dirs."
  if ! $dry; then
    if [ ! -d "/nix" ]; then
      # wrapped in the conditional so we don't always prompt for password
      sudo mkdir /nix
    fi
    mkdir -p "${XDG_CONFIG_HOME}"
    mkdir -p "${XDG_DATA_HOME}"
    mkdir -p "${XDG_CACHE_HOME}"
    mkdir -p "${XDG_STATE_HOME}"
    mkdir -p "${XDG_BIN_HOME}"
    mkdir -p "${XDG_LIB_HOME}"
    mkdir -p "${XDG_TMP_HOME}"
    mkdir -p "${XDG_OPT_HOME}"
    mkdir -p "${XDG_VAR_HOME}"
    mkdir -p "${HOME}/bin"
    mkdir -p "${HOME}/tmp"
  fi

  return 0
}

cmd_python() {
  require "curl"

  # Define the stable versions of python
  local vmain="3.5.2"
  local v3="${vmain}"
  local v2="2.7.12"
  local pyenv
  pyenv="${PYENV_ROOT}/bin/pyenv"

  get_pyenv

  # create virtual envs for neovim
  # NOTE: the versions here should be updated occasionally
  local vers=( "${v2}" "${v3}" "${vmain}" )
  for ver in "${vers[@]}"; do
    if ! $dry && [ ! -e "${PYENV_ROOT}/versions/${ver}" ]; then
      echo --verbose "Pyenv is installing ${ver}".
      ${pyenv} install "${ver}"
    fi
  done


  echo --verbose "Creating neovim virtual envs."
  if ! $dry; then
    ${pyenv} virtualenv "${v2}" "neovim2"
    ${pyenv} virtualenv "${v3}" "neovim3"
    eval "$(${pyenv} init -)"
  fi


  echo --verbose "Installing modules in neovim virtual envs."
  local venvs=( "neovim2" "neovim3" )
  for venv in "${venvs[@]}"; do
    local pip="${PYENV_ROOT}versions/${venv}/bin/pip"
    if ! $dry; then
      "${pip}" install --upgrade pip
      "${pip}" install --upgrade "neovim"
      "${pip}" install --upgrade "jedi"
    fi
  done

  # link some python binaries so they are available to external
  # programs, regardless of the current python environment.
  # This is mostly to expose linters and autoformatters.
  echo --verbose "Installing and linking python binaries."
  if ! $dry; then
    ${pyenv} global "${vmain}" "${v3}" "${v2}"
    local mods=( flake8 autoflake pylint ipython )
    pip="${PYENV_ROOT}/versions/${vmain}/bin/pip"
    for mod in "${mods[@]}"; do
      "${pip}" install --upgrade "${mod}"
      ${pyenv} rehash
      local dest="${XDG_BIN_HOME}/${mod}"
      [ -L "${dest}" ] && rm "${dest}"
      ln -s "${PYENV_ROOT}/versions/${vmain}/bin/${mod}" "${dest}"
    done
  fi

  return 0
}

cmd_neovim() {
  require "curl"

  # install neovim: maybe this should be done via source?
  ensure "nvim" "neovim"
  cmd_python
}

# FIXME for testing purposes
cmd_zsh() {
  ensure "zsh"
  setup_zsh
  exit 0
}

cmd_install() {
  echo "Installing dotfiles."

  # If we are bootstrapping, we have already called cmd_init.
  $bootstrap || cmd_init "${@}"

  # update a few core packages
  get_nix
  get_pkg "git"
  get_pkg "zsh"

  get_config_deps
  cmd_zsh
  cmd_neovim
  cmd_link
  echo "Finished installing."
  exit 0
}

parse_cmd() {
  local cmd="${1}"
  shift
  # Execute the named command and pass it the args that follow.
  # For example, "cmd_${@}" could expand to cmd_foo arg1 arg2 arg3.
  case "${cmd}" in
    deps | init | install | neovim | python | zsh)
      "cmd_${cmd}" "${@}"
      exit 0
      ;;
    link | ln)
      cmd_link "${@}"
      exit 0
      ;;
    help)
      display_help
      exit 0
      ;;
    *)
      echo "Command ${cmd} not recognized".
      display_help
      exit 1
      ;;
  esac
}


# potentially bootstrap necessary environment variables and creates dirs  by sourcing the
# .profile file included in the dotfiles repo.  If this file does not
# exist, then we try to bootstrap by installing git and fetching the
# dotfiles repo.
bootstrap_check() {
  # Source dotfiles profile to get external vars, else try to bootstrap.
  echo --verbose "Checking for need to bootstrap."
  if [ ! -e "${DOTFILES}/README.md" ]; then
    bootstrap=true
    echo --verbose "Attempting to bootstrap."
    # user should be calling install ostype distro install-comand
    if [ "${1}" != "install" ]; then
      echo --error "Can only bootstrap when install command is passed."
      exit 1
    fi
    cmd_init "${@:2}"
    get_git_repo "${DOTFILES_REPO}" "${DOTFILES}"
  fi

  if [ ! -e "${DOTFILES}/README.md" ]; then
    echo --error "Bootstrap was unable to clone ${DOTFILES_REPO}"
    exit 1
  else
    echo --verbose "No need to bootstrap."
  fi

}

# init is the first thing run.
# It parses the script options.
init() {
  parse_opts "${@}"
  set_ostype # FIXME: do we care?

  # Set up echoging, if necessary.  This is controlled by the -l option.
  if $logging; then
    # Append to both console and log. In particular, external programs will
    # still push things to the console and echo.
    # http://stackoverflow.com/questions/18460186/writing-outputs-to-echo-file-and-console
    exec > >(tee -a "${LOGFILE}" )
    exec 2> >(tee  -a "${LOGFILE}" >&2)
    echo "Logging to ${LOGFILE}"
  fi

}

main() {

  init "${@}"
  shift $((OPTIND - 1)) # shift past options to sub-commands
  echo --debug "Input command after opt parsing: ${*}"
  bootstrap_check "${@}"

  # Dispatch the appropriate command.
  if [ -z "${1}" ]; then
    display_help
    return 0
  else
    parse_cmd "${@}"
  fi
  return 0
}

main "${@}"

